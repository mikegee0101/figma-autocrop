<script>
  class AutocropperWorker {
    constructor(image, imageBytes, noiseThreshold) {
      this._imageBytes = imageBytes
      this._noiseThreshold = noiseThreshold
      this._image = image
    }

    getCropDescription() {
      const canvas = document.createElement('canvas')
      const context = canvas.getContext('2d')
      
      canvas.width = this._image.width
      canvas.height = this._image.height
      context.drawImage(this._image, 0, 0)

      this._imageData = context.getImageData(0, 0, this._image.width, this._image.height)

      const topCropHeight = this._getTopCropHeight()
      const bottomCropHeight = this._getBottomCropHeight()
      const leftCropWidth = this._getLeftCropWidth()
      const rightCropWidth = this._getRightCropWidth()

      return {
        topCropHeight: topCropHeight,
        leftCropWidth: leftCropWidth,
        cropWidth: this._image.width - (rightCropWidth + leftCropWidth),
        cropHeight: this._image.height - (bottomCropHeight + topCropHeight),
        imageWidth: this._image.width,
        imageHeight: this._image.height
      }
    }

    _isWhiteAt(x, y) {
      const [redIndex, greenIndex, blueIndex, alphaIndex] = this._getColorIndicesForPoint(x, y)

      return this._imageData.data[redIndex] > this._noiseThreshold
        && this._imageData.data[blueIndex] > this._noiseThreshold
        && this._imageData.data[greenIndex] > this._noiseThreshold
    }

    _getColorIndicesForPoint(x, y) {
      const red = y * (this._image.width * 4) + x * 4;
      return [red, red + 1, red + 2, red + 3];
    }

    _getTopCropHeight() {
      let height = 0
      for (let y = 0; y < this._image.height; y++) {
        for (let x = 0; x < this._image.width; x++) {
          if (!this._isWhiteAt(x, y)) {
            return height
          }
        }
        height++
      }
      return height
    }

    _getBottomCropHeight() {
      let height = 0
      for (let y = this._image.height - 1; y >= 0; y--) {
        for (let x = this._image.width - 1; x >= 0; x--) {
          if (!this._isWhiteAt(x, y)) {
            return height
          }
        }
        height++
      }
      return height
    }

    _getLeftCropWidth() {
      let width = 0
      for (let x = 0; x < this._image.width; x++) {
        for (let y = 0; y < this._image.height; y++) {
          if (!this._isWhiteAt(x, y)) {
            return width
          }
        }
        width++
      }
      return width
    }

    _getRightCropWidth() {
      let width = 0
      for (let x = this._image.width - 1; x >= 0; x--) {
        for (let y = this._image.height - 1; y >= 0 ; y--) {
          if (!this._isWhiteAt(x, y)) {
            return width
          }
        }
        width++
      }
      return width
    }
  }

  class Decoder {
    static async decodeImageBytesToImage(imageBytes) {
      const url = URL.createObjectURL(new Blob([imageBytes]))
      const image = await new Promise((resolve, reject) => {
        let img = new Image()
        img.onload = () => resolve(img)
        img.onerror = () => reject()
        img.src = url
      })
      return image
    }
  }

  window.onmessage = async (event) => {
    const imageBytes = event.data.pluginMessage.imageBytes
    const noiseThreshold = event.data.pluginMessage.noiseThreshold

    const image = await Decoder.decodeImageBytesToImage(imageBytes)

    const autocropperWorker = new AutocropperWorker(image, imageBytes, noiseThreshold)
    const cropDescription  = await autocropperWorker.getCropDescription()
    
    if (cropDescription.leftCropWidth === image.width && cropDescription.topCropHeight === image.height) {
      window.parent.postMessage({
        pluginMessage: {
          status: 'no-remaining-image',
          data: {} 
        }
      }, '*')
    } else if (cropDescription.leftCropWidth === 0 && cropDescription.topCropHeight === 0) {
      window.parent.postMessage({
        pluginMessage: {
          status: 'nothing-to-crop',
          data: {} 
        }
      }, '*')
    } else {
      window.parent.postMessage({
        pluginMessage: {
          status: 'success',
          data: cropDescription
        }
      }, '*')
    }
  }
</script>