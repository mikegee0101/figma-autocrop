<script>
  class AutocropperWorker {
    constructor(imageBytes, noiseThreshold) {
      this.imageBytes = imageBytes // TODO Underscore properties that are private everywhere
      this.noiseThreshold = noiseThreshold
      this.canvas = document.createElement('canvas')
      this.context = this.canvas.getContext('2d') // TODO Can I immediately use this.canvas?
    }

    async crop() {
      const image = await this._decode()

      this.canvas.width = image.width
      this.canvas.height = image.height
      this.context.drawImage(image, 0, 0)

      const imageData = this.context.getImageData(0, 0, image.width, image.height)
      const cropMetrics = this._getCropMetrics(image, imageData)

      this.canvas.width = cropMetrics.cropWidth
      this.canvas.height = cropMetrics.cropHeight
      this.context.drawImage(
        image,
        cropMetrics.leftCropWidth,
        cropMetrics.topCropHeight,
        cropMetrics.cropWidth,
        cropMetrics.cropHeight,
        0,
        0,
        cropMetrics.cropWidth,
        cropMetrics.cropHeight
      )

      const croppedImageBytes = await this._encode()

      return {
        croppedImageBytes: croppedImageBytes,
        cropWidth: cropMetrics.cropWidth,
        cropHeight: cropMetrics.cropHeight
      }
    }

    _getCropMetrics(image, imageData) {
      const topCropHeight = this._getTopCropHeight(image, imageData)
      const bottomCropHeight = this._getBottomCropHeight(image, imageData)
      const leftCropWidth = this._getLeftCropWidth(image, imageData)
      const rightCropWidth = this._getRightCropWidth(image, imageData)

      return {
        topCropHeight: topCropHeight,
        bottomCropHeight: bottomCropHeight,
        leftCropWidth: leftCropWidth,
        rightCropWidth: rightCropWidth,
        cropWidth: image.width - (rightCropWidth + leftCropWidth),
        cropHeight: image.height - (bottomCropHeight + topCropHeight)
      }
    }

    _isWhiteAt(x, y, image, imageData) {
      let [redIndex, greenIndex, blueIndex, alphaIndex] = this._getColorIndicesForPoint(x, y, image.width)

      return imageData.data[redIndex] > this.noiseThreshold
        && imageData.data[blueIndex] > this.noiseThreshold
        && imageData.data[greenIndex] > this.noiseThreshold
    }

    _getColorIndicesForPoint(x, y, width) {
      let red = y * (width * 4) + x * 4;
      return [red, red + 1, red + 2, red + 3];
    }

    _getTopCropHeight(image, imageData) {
      var height = 0
      for (var y = 0; y < image.height; y++) {
        for (var x = 0; x < image.width; x++) {
          if (!this._isWhiteAt(x, y, image, imageData)) {
            return height // TODO Handle when height == image.height
          }
        }
        height++
      }
    }

    _getBottomCropHeight(image, imageData) {
      var height = 0
      for (var y = image.height - 1; y >= 0; y--) {
        for (var x = image.width - 1; x >= 0; x--) {
          if (!this._isWhiteAt(x, y, image, imageData)) {
            return height // TODO Handle when height == image.height
          }
        }
        height++
      }
    }

    _getLeftCropWidth(image, imageData) {
      var width = 0
      for (var x = 0; x < image.width; x++) {
        for (var y = 0; y < image.height; y++) {
          if (!this._isWhiteAt(x, y, image, imageData)) {
            return width // TODO Handle when width == image.width
          }
        }
        width++
      }
    }

    _getRightCropWidth(image, imageData) {
      var width = 0
      for (var x = image.width - 1; x >= 0; x--) {
        for (var y = image.height - 1; y >= 0 ; y--) {
          if (!this._isWhiteAt(x, y, image, imageData)) {
            return width // TODO Handle when width == image.width
          }
        }
        width++
      }
    }

    async _encode() {
      return await new Promise((resolve, reject) => {
        this.canvas.toBlob(blob => {
          let reader = new FileReader()
          reader.onload = () => resolve(new Uint8Array(reader.result))
          reader.onerror = () => reject(new Error('Could not read from blob'))
          reader.readAsArrayBuffer(blob)
        })
      })
    }

    async _decode() {
      let url = URL.createObjectURL(new Blob([this.imageBytes]))
      let image = await new Promise((resolve, reject) => {
        let img = new Image()
        img.onload = () => resolve(img)
        img.onerror = () => reject()
        img.src = url
      })
      return image
    }
  }

  window.onmessage = async (event) => {
    const imageBytes = event.data.pluginMessage.imageBytes
    const noiseThreshold = event.data.pluginMessage.noiseThreshold

    const autocropperWorker = new AutocropperWorker(imageBytes, noiseThreshold)
    const cropDescription = await autocropperWorker.crop()

    window.parent.postMessage({
      pluginMessage: {
        croppedImageBytes: cropDescription.croppedImageBytes,
        cropWidth: cropDescription.cropWidth,
        cropHeight: cropDescription.cropHeight
      }
    }, '*')
  }
</script>