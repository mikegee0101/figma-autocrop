<script>
  class AutocropperWorker {
    constructor(image, imageBytes, noiseThreshold) {
      this._imageBytes = imageBytes
      this._noiseThreshold = noiseThreshold
      this._canvas = document.createElement('canvas')
      this._image = image
    }

    get _context() {
      return this._canvas.getContext('2d')
    }

    set _context(newContext) {
      this._context = newContext
    }

    async getCroppedCanvas() {
      this._canvas.width = this._image.width
      this._canvas.height = this._image.height
      this._context.drawImage(this._image, 0, 0)

      const imageData = this._context.getImageData(0, 0, this._image.width, this._image.height)
      const cropMetrics = this._getCropMetrics(imageData)

      this._canvas.width = cropMetrics.cropWidth
      this._canvas.height = cropMetrics.cropHeight
      this._context.drawImage(
        this._image,
        cropMetrics.leftCropWidth,
        cropMetrics.topCropHeight,
        cropMetrics.cropWidth,
        cropMetrics.cropHeight,
        0,
        0,
        cropMetrics.cropWidth,
        cropMetrics.cropHeight
      )
      return this._canvas
    }

    _getCropMetrics(imageData) {
      const topCropHeight = this._getTopCropHeight(imageData)
      const bottomCropHeight = this._getBottomCropHeight(imageData)
      const leftCropWidth = this._getLeftCropWidth(imageData)
      const rightCropWidth = this._getRightCropWidth(imageData)

      return {
        topCropHeight: topCropHeight,
        bottomCropHeight: bottomCropHeight,
        leftCropWidth: leftCropWidth,
        rightCropWidth: rightCropWidth,
        cropWidth: this._image.width - (rightCropWidth + leftCropWidth),
        cropHeight: this._image.height - (bottomCropHeight + topCropHeight)
      }
    }

    _isWhiteAt(x, y, imageData) {
      const [redIndex, greenIndex, blueIndex, alphaIndex] = this._getColorIndicesForPoint(x, y)

      return imageData.data[redIndex] > this._noiseThreshold
        && imageData.data[blueIndex] > this._noiseThreshold
        && imageData.data[greenIndex] > this._noiseThreshold
    }

    _getColorIndicesForPoint(x, y) {
      const red = y * (this._image.width * 4) + x * 4;
      return [red, red + 1, red + 2, red + 3];
    }

    _getTopCropHeight(imageData) {
      let height = 0
      for (let y = 0; y < this._image.height; y++) {
        for (let x = 0; x < this._image.width; x++) {
          if (!this._isWhiteAt(x, y, imageData)) {
            return height
          }
        }
        height++
      }
    }

    _getBottomCropHeight(imageData) {
      let height = 0
      for (let y = this._image.height - 1; y >= 0; y--) {
        for (let x = this._image.width - 1; x >= 0; x--) {
          if (!this._isWhiteAt(x, y, imageData)) {
            return height
          }
        }
        height++
      }
    }

    _getLeftCropWidth(imageData) {
      let width = 0
      for (let x = 0; x < this._image.width; x++) {
        for (let y = 0; y < this._image.height; y++) {
          if (!this._isWhiteAt(x, y, imageData)) {
            return width
          }
        }
        width++
      }
    }

    _getRightCropWidth(imageData) {
      let width = 0
      for (let x = this._image.width - 1; x >= 0; x--) {
        for (let y = this._image.height - 1; y >= 0 ; y--) {
          if (!this._isWhiteAt(x, y, imageData)) {
            return width
          }
        }
        width++
      }
    }
  }

  class EncoderDecoder {
    static async encodeCanvasToImageBytes(canvas) {
      return await new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          const reader = new FileReader()
          reader.onload = () => resolve(new Uint8Array(reader.result))
          reader.onerror = () => reject(new Error('Could not read from blob'))
          reader.readAsArrayBuffer(blob)
        })
      })
    }

    static async decodeImageBytesToImage(imageBytes) {
      const url = URL.createObjectURL(new Blob([imageBytes]))
      const image = await new Promise((resolve, reject) => {
        let img = new Image()
        img.onload = () => resolve(img)
        img.onerror = () => reject()
        img.src = url
      })
      return image
    }
  }

  window.onmessage = async (event) => {
    const imageBytes = event.data.pluginMessage.imageBytes
    const noiseThreshold = event.data.pluginMessage.noiseThreshold

    const image = await EncoderDecoder.decodeImageBytesToImage(imageBytes)

    const autocropperWorker = new AutocropperWorker(image, imageBytes, noiseThreshold)
    const croppedCanvas = await autocropperWorker.getCroppedCanvas()

    if (croppedCanvas.width === 0 && croppedCanvas.height === 0) {
      window.parent.postMessage({ pluginMessage: { status: 'no-remaining-image', data: {} } }, '*')
    } else {
      const croppedImageBytes = await EncoderDecoder.encodeCanvasToImageBytes(croppedCanvas)

      window.parent.postMessage({
        pluginMessage: {
          status: 'success',
          data: {
            croppedImageBytes: croppedImageBytes,
            cropWidth: croppedCanvas.width,
            cropHeight: croppedCanvas.height
          }
        }
      }, '*')
    }
  }
</script>