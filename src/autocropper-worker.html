<script>
  class AutocropperWorker {
    constructor(image, imageBytes, noiseThreshold) {
      this.imageBytes = imageBytes // TODO Underscore properties that are private everywhere
      this.noiseThreshold = noiseThreshold
      this.canvas = document.createElement('canvas')
      this.image = image
    }

    get context() {
      return this.canvas.getContext('2d')
    }

    set context(newContext) {
      this.context = newContext
    }

    async getCroppedCanvas() {
      this.canvas.width = this.image.width
      this.canvas.height = this.image.height
      this.context.drawImage(this.image, 0, 0)

      const imageData = this.context.getImageData(0, 0, this.image.width, this.image.height)
      const cropMetrics = this._getCropMetrics(imageData)

      this.canvas.width = cropMetrics.cropWidth
      this.canvas.height = cropMetrics.cropHeight
      this.context.drawImage(
        this.image,
        cropMetrics.leftCropWidth,
        cropMetrics.topCropHeight,
        cropMetrics.cropWidth,
        cropMetrics.cropHeight,
        0,
        0,
        cropMetrics.cropWidth,
        cropMetrics.cropHeight
      )
      return this.canvas
    }

    _getCropMetrics(imageData) {
      const topCropHeight = this._getTopCropHeight(imageData)
      const bottomCropHeight = this._getBottomCropHeight(imageData)
      const leftCropWidth = this._getLeftCropWidth(imageData)
      const rightCropWidth = this._getRightCropWidth(imageData)

      return {
        topCropHeight: topCropHeight,
        bottomCropHeight: bottomCropHeight,
        leftCropWidth: leftCropWidth,
        rightCropWidth: rightCropWidth,
        cropWidth: this.image.width - (rightCropWidth + leftCropWidth),
        cropHeight: this.image.height - (bottomCropHeight + topCropHeight)
      }
    }

    _isWhiteAt(x, y, imageData) {
      const [redIndex, greenIndex, blueIndex, alphaIndex] = this._getColorIndicesForPoint(x, y)

      return imageData.data[redIndex] > this.noiseThreshold
        && imageData.data[blueIndex] > this.noiseThreshold
        && imageData.data[greenIndex] > this.noiseThreshold
    }

    _getColorIndicesForPoint(x, y) {
      const red = y * (this.image.width * 4) + x * 4;
      return [red, red + 1, red + 2, red + 3];
    }

    _getTopCropHeight(imageData) {
      let height = 0
      for (let y = 0; y < this.image.height; y++) {
        for (let x = 0; x < this.image.width; x++) {
          if (!this._isWhiteAt(x, y, imageData)) {
            return height // TODO Handle when height == image.height
          }
        }
        height++
      }
    }

    _getBottomCropHeight(imageData) {
      let height = 0
      for (let y = this.image.height - 1; y >= 0; y--) {
        for (let x = this.image.width - 1; x >= 0; x--) {
          if (!this._isWhiteAt(x, y, imageData)) {
            return height // TODO Handle when height == image.height
          }
        }
        height++
      }
    }

    _getLeftCropWidth(imageData) {
      let width = 0
      for (let x = 0; x < this.image.width; x++) {
        for (let y = 0; y < this.image.height; y++) {
          if (!this._isWhiteAt(x, y, imageData)) {
            return width // TODO Handle when width == image.width
          }
        }
        width++
      }
    }

    _getRightCropWidth(imageData) {
      let width = 0
      for (let x = this.image.width - 1; x >= 0; x--) {
        for (let y = this.image.height - 1; y >= 0 ; y--) {
          if (!this._isWhiteAt(x, y, imageData)) {
            return width // TODO Handle when width == image.width
          }
        }
        width++
      }
    }
  }

  class EncoderDecoder {
    static async encodeCanvasToImageBytes(canvas) {
      return await new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          const reader = new FileReader()
          reader.onload = () => resolve(new Uint8Array(reader.result))
          reader.onerror = () => reject(new Error('Could not read from blob'))
          reader.readAsArrayBuffer(blob)
        })
      })
    }

    static async decodeImageBytesToImage(imageBytes) {
      const url = URL.createObjectURL(new Blob([imageBytes]))
      const image = await new Promise((resolve, reject) => {
        let img = new Image()
        img.onload = () => resolve(img)
        img.onerror = () => reject()
        img.src = url
      })
      return image
    }
  }

  window.onmessage = async (event) => {
    const imageBytes = event.data.pluginMessage.imageBytes
    const noiseThreshold = event.data.pluginMessage.noiseThreshold

    const image = await EncoderDecoder.decodeImageBytesToImage(imageBytes)

    const autocropperWorker = new AutocropperWorker(image, imageBytes, noiseThreshold)
    const croppedCanvas = await autocropperWorker.getCroppedCanvas()

    const croppedImageBytes = await EncoderDecoder.encodeCanvasToImageBytes(croppedCanvas)

    window.parent.postMessage({
      pluginMessage: {
        croppedImageBytes: croppedImageBytes,
        cropWidth: croppedCanvas.width,
        cropHeight: croppedCanvas.height
      }
    }, '*')
  }
</script>