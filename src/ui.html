<script>
  window.onmessage = async(event) => {
    const noiseThreshold = event.data.pluginMessage.noiseThreshold
    const imageBytes = event.data.pluginMessage.imageBytes

    const canvas = document.createElement('canvas')
    const context = canvas.getContext('2d')

    const image = await decode(canvas, context, imageBytes)

    canvas.width = image.width
    canvas.height = image.height
    context.drawImage(image, 0, 0)

    const imageData = context.getImageData(0, 0, image.width, image.height)

    const cropMetrics = getCropMetrics(image, imageData, noiseThreshold)

    canvas.width = cropMetrics.cropWidth
    canvas.height = cropMetrics.cropHeight
    context.drawImage(
      image,
      cropMetrics.leftCropWidth,
      cropMetrics.topCropHeight,
      cropMetrics.cropWidth,
      cropMetrics.cropHeight,
      0,
      0,
      cropMetrics.cropWidth,
      cropMetrics.cropHeight
    )

    const croppedImageBytes = await encode(canvas, context, imageData)

    window.parent.postMessage({
      pluginMessage: {
        croppedImageBytes: croppedImageBytes,
        cropWidth: cropMetrics.cropWidth,
        cropHeight: cropMetrics.cropHeight
      }
    }, '*')
  }

  function getCropMetrics(image, imageData, noiseThreshold) {
    const topCropHeight = getTopCropHeight(image, imageData, noiseThreshold)
    const bottomCropHeight = getBottomCropHeight(image, imageData, noiseThreshold)
    const leftCropWidth = getLeftCropWidth(image, imageData, noiseThreshold)
    const rightCropWidth = getRightCropWidth(image, imageData, noiseThreshold)

    return {
      topCropHeight: topCropHeight,
      bottomCropHeight: bottomCropHeight,
      leftCropWidth: leftCropWidth,
      rightCropWidth: rightCropWidth,
      cropWidth: image.width - (rightCropWidth + leftCropWidth),
      cropHeight: image.height - (bottomCropHeight + topCropHeight)
    }
  }

  function isWhiteAt(x, y, image, imageData, noiseThreshold) {
    let [redIndex, greenIndex, blueIndex, alphaIndex] = getColorIndicesForPoint(x, y, image.width)

    return imageData.data[redIndex] > noiseThreshold &&
      imageData.data[blueIndex] > noiseThreshold &&
      imageData.data[greenIndex] > noiseThreshold
  }

  function getColorIndicesForPoint(x, y, width) {
    let red = y * (width * 4) + x * 4;
    return [red, red + 1, red + 2, red + 3];
  }

  function getTopCropHeight(image, imageData, noiseThreshold) {
    var height = 0
    for (var y = 0; y < image.height; y++) {
      for (var x = 0; x < image.width; x++) {
        if (!isWhiteAt(x, y, image, imageData, noiseThreshold)) {
          return height
        }
      }
      height++
    }
  }

  function getBottomCropHeight(image, imageData, noiseThreshold) {
    var height = 0
    for (var y = image.height - 1; y >= 0; y--) {
      for (var x = image.width - 1; x >= 0; x--) {
        if (!isWhiteAt(x, y, image, imageData, noiseThreshold)) {
          return height
        }
      }
      height++
    }
  }

  function getLeftCropWidth(image, imageData, noiseThreshold) {
    var width = 0
    for (var x = 0; x < image.width; x++) {
      for (var y = 0; y < image.height; y++) {
        if (!isWhiteAt(x, y, image, imageData, noiseThreshold)) {
          return width
        }
      }
      width++
    }
  }

  function getRightCropWidth(image, imageData, noiseThreshold) {
    var width = 0
    for (var x = image.width - 1; x >= 0; x--) {
      for (var y = image.height - 1; y >= 0; y--) {
        if (!isWhiteAt(x, y, image, imageData, noiseThreshold)) {
          return width
        }
      }
      width++
    }
  }

  async function encode(canvas, context, imageData) {
    return await new Promise((resolve, reject) => {
      canvas.toBlob(blob => {
        let reader = new FileReader()
        reader.onload = () => resolve(new Uint8Array(reader.result))
        reader.onerror = () => reject(new Error('Could not read from blob'))
        reader.readAsArrayBuffer(blob)
      })
    })
  }

  async function decode(canvas, context, imageBytes) {
    let url = URL.createObjectURL(new Blob([imageBytes]))
    let image = await new Promise((resolve, reject) => {
      let img = new Image()
      img.onload = () => resolve(img)
      img.onerror = () => reject()
      img.src = url
    })
    return image
  }
</script>